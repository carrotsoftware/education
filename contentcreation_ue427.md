# Как подготовить ассеты на Unreal Engine 4.27 для Carrot

>В этом разделе на примере вы узнаете, как создавать ассеты, выполняющие действия по кнопке, готовые для работы с Carrot.
<br>Процессы моделлирования, текстурирования и т.д. затрагиваться не будут.
<br>
<br>В раздел входит: 
<br>1. Структура папок и нейминг ассетов внутри Content Browser.
<br>1.1. Структура папок
<br>1.2. Нейминг ассетов
<br>1.2.1 Нейминг материалов
<br>1.2.2 Нейминг текстур
<br>2. Иерархия элементов внутри World Outliner.
<br>3. Работа со слоями внутри Editor.
<br>4. Создание и настройка управляющей логики под плейлист Carrot.
<br>5. Финальные действия перед отправкой ассета.

Документ находится в процессе разработки структура и наполнение могут изменяться.

## 1. Структура папок и нейминг ассетов внутри Content Browser. Как правильно это делать.

**Пример, к следующему выпуску новостной программы нам прислали следующие подводки:**

1. На подводку к сюжету про сахар ставим свеклоуборочный комбайн, позади него гора сахара, которую он образно произвел. Сыпать из комбайна на гору сахар не нужно, но у него что-то должно двигаться, работать.

2. На подводку к сюжету о логистике нужен корабль контейнеровоз и кран, загружающий/разгружающий контейнер. Можно попробовать налить воды ниже уровня сцены, но только если она будет реалистичной.

3. Великая Европейская стена. Типа отделяет Запад от России. Стена наподобие китайской. Идет из экрана ( из за горизонта ) - слева от таблетки. Извилистая. Перед таблеткой как бы ворота в стене. Перед ней стоит фура , современная. Типа не может попасть на запад.

4. Тема про жилье. Слева от таблетки строительный кран, со стрелой над таблеткой, кран поднимает плиту. Справа от таблетки строящийся дом( еще недостроен до крыши) Кран работает, плиту переносит на дом. В какой то момент плита зависает на таблеткой - типа стройка остановилась. Надо еще небо. А по периметру над декорациями высятся готовые высотки, целый город

Из этого списка мы выбрали подводку к сюжету про сахарную гору и комбайн с определенным действием по кнопке. С чего начать?

<br>

### 1.1. Структура папок
У каждого ассета должна быть своя папка, желательно с порядковым номером и написанием капсом. Это очень ***круто*** и ***удобно***.

По имени и нумерации найти папку со всем необходимым проще, чем метаться между **всем** контентом, не правда ли? А ведь ещё это можете быть не вы, а инженер на мероприятии, которому погружаться в особенности вашего творческого беспорядка будет некогда.

Лучше всего это сделать сразу, т.к. потом в процессе переименовывания/перетаскивания у ассетов могут слететь ссылки на меши/материалы/текстуры, либо анрил просто сложится. Когда такое произойдет, будет очень ***неприятно***.

В `Content Browser`, внутри `Content` создаём папку с названием содержимого. Это может быть название подводки, сюжета или главного объекта. В нашем случае это `01_SUGAR`.

Нумерация папки соответствует нумерации списка подводок к следующему выпуску:

![Simple Folder Structure](images/contentcreation_ue427/folderstructure_01.png)

В созданной папке `01_SUGAR` создаем следующие подпапки по мере надобности:
 
Название папки | Описание
-|-
**Animations** | Анимации для Skeletal Mesh, алембики, секвенцеры и т.д.
**Blueprints** | Управляющие блупринты, префабы объектов, Material Parameter Collection и всё остальное, что связано с логикой.
**FX** | Эффекты Niagara и Cascade
**Levels** | Уровни с объектами
**Materials** | -
**Mesh** | Сюда кидаем наши импортнутые FBX, OBJ и т.д.
**Textures** | -

<br>Если объектов внутри одной подводки несколько, то сначала надо создать папку с именем объекта, а внутри неё уже устраивать наполнение по умолчанию. У нас эта структура будет иметь следующий вид:

![Advanced Folder Structure](images/contentcreation_ue427/folderstructure_02.png)

Название папки | Описание
-|-
`01_SUGAR` | Название папки с подводкой
`01_Harvester` | Папка со всем содержимым для свеклоуборочного комбайна
`02_Sugarpile` | Папка со всем содержимым для горы сахара

> В примере выше объекты не имеют отдельных уровней под комбайн и гору, т.к. объекты простые, поэтому они собраны вместе на едином уровне. Папка `_Levels` находится в корне папки `01_SUGAR` и визуально выделена нижним подчеркиванием.
<br>

### 1.2. Нейминг ассетов
#### 1.2.1 Нейминг материалов

Материалы называем также как и ассет, если требуется разбить на несколько материалов, то пишем:
<br><br>`M_` + `название ассета` + `_название детали или группы деталей`
<br><br>Если используем мастер материалы, то пишем:
<br><br>`MM_` + `название ассета`, а инстансы подписываем `MI_` + `название ассета` + `_название детали или группы деталей`

> Кому интересны все рекомендованные префиксы ассетов — [ссылка на док](https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/AssetNaming/).

<br>**Пример:**
    
    M_Harvester_glass
    M_Harvester_wheels
    M_Harvester_chassis
    M_Harvester_gum
    M_Harvester_plastic
    MM_Harvester
    MI_Harvester_wheels
<br>

#### 1.2.2 Нейминг текстур

Текстуры называем по той же логике что и все остальное: `T_название ассета_суффикс`.

> **T** for **ТЕКСТУРА**
<br>

Тип текстуры | Суффикс
-|-
**Base color** | _D
**Metallic** | _M
**Specular** | _S
**Roughness** | _R
**Normal** | _N
**Displacement** | _DP
**Ambient Occlusion** | _AO
**Height Map** | _H
**Flow Map** | _FM
**Light Map (fake)** | _L
**Mask** | _MA

<br>

**Пример:**
    
    T_Harvester_D
    T_Harvester_M
    и.т.д.

## 2. Иерархия элементов внутри World Outliner. Как надо, чтобы инженеры зауважали.

Первым делом мы создаём новый уровень, в который будем накидывать объекты и настраивать, по первому времени, ассеты. Называем его по имени основного объекта, либо подводки под которую ассеты создаются без префиксов: `название`.

Если уровень составной или имеет несколько итераций, то пишем `название` + `_назначение` + `_порядкой номер`.

Если над проектом пыхтят несколько трудяг одновременно, то каждый создаёт себе новый уровень с обозначением того, что на этом уровне делалось.

<br>

**Пример:**
    
    01_SUGAR
    01_SUGAR_lighting
    01_SUGAR_lighting_02
    01_SUGAR_02_environment_03
    и.т.д.
> Структура уровней, описанная в примере уровни используется при создании глобальных сцен (студии, пустыни, города, всякие ландшафты). 
<br><br>Отдельно освещение, отдельно объекты ближнего плана, дальнего плана, ключевые объекты и т.д.
<br>

Открываем уровень, кидаем объекты, развлекаемся.

В процессе творения получилось что-то такое:
<br>

![Asset Viewport Preview](images/contentcreation_ue427/viewport_01.png)

<br>

Cтруктура папок создана, текстуры и анимации раскиданы по папкам, материалы накручены, блупринты накожены, свет выставлен. **Что дальше?**

После всех наших первичных манипуляций иерархия уровня, скорее всего, будет выглядеть так:

![Outliner hierarchy unsorted](images/contentcreation_ue427/outliner_hierarchy_unsorted.png)

> В данном примере мы выбрали реализацию через упаковку геометрии с анимацией и логикой напрямую в **Actor Blueprint** (ещё называют Prefab) `BP_Harvester` и `BP_SugarPile`. Зачем и почему, как сделать, какие ещё виды реализации существуют, читаем [здесь](TODO).
<br>

В итоге получается полная каша и неразбериха. Как создатель вы, возможно, и сможете ориентироваться в подобном, но любой другой после вас **вряд ли**. 

Каким образом мы должны сформировать иерархию? Какие задачи она должна выполнять?

1. Объекты должны быть легкодоступными для поиска (визуального и по ключевым словам в фильтре)
2. Должна быть возможность перетаскивать сцену со всеми объектами и освещением за один родительский нулик.

Нам нужно сделать так, чтобы эти объекты было легко найти среди остального контента `World Outliner` собранного на эфир проекте, мы могли перетаскивать, крутить и масштабировать объекты, причем чтобы мы могли двигать объект как вместе со всем освещением, так и отдельно от него, не ломая выполнение логики в **Actor Blueprint**. Тут на помощь приходят `Empty Actor`.

Добавляем `Empty Actor` для перемещения всего комбайна с освещением, называем его `null_Harvester`. Прикрепляем `BP_Harvester` и нужные источники света к созданному нулику.

Создаём ещё один `Empty Actor`, но уже для перемещения комбайна отдельно от освещения, называем его `hlp_Harvester`. Прикрепляем `BP_Harvester`.

В зависимости от задачи, объектом нужно будет манипулировать относительно его собственного **Pivot point**, либо относительно другого объекта. В наше случае комбайн должен вращаться вокруг собственной нулевой точки, поэтому **важно**, чтобы **Pivot point** у объекта и нулика были в одной точке, напоминаю, что при работе через [Multi-user](TODO) мы не можем трогать **Blueprint Actor** напрямую:

![Scene Pivot point position](images/contentcreation_ue427/scene_pivotposition.png)

На выходе мы должны получить следующую иерархию уровня:

![Outliner hierarchy sorted](images/contentcreation_ue427/outliner_hierarchy_sorted.png)

Теперь, двигая за соответствующие дамики мы можем манипулировать как всей сценой целиком, так и отдельными объектами.

## 3. Работа со слоями внутри Editor.

После завершения всех работ созданный контент требуется вынести в отдельный слой. Делается это для того, чтобы в собранном проекте можно было быстро скрыть и отобразить целую группу элементов на уровне.

> Опция работает исключительно внутри редактора, аналогична глазу напротив объекта в `World Outliner`, на проект в режиме **Game** она никак не влияет.

Т.е. чтобы при вместо этого:

![Outliner Layers Off](images/contentcreation_ue427/outliner_layers_off.png)

Можно было сделать вот так:

![Outliner Layers On](images/contentcreation_ue427/outliner_layers_on.png)

Для того, чтобы добавить объекты в слой:

1. Выделяем в `World Outliner` нужные объекты.
    > Если объекты лежат в пределах одного уровня, то для быстрого выбора можно включить режим `Only in Current Level`. Для этого внутри вкладки `Levels` двойным кликом выделяем нужный уровень, далее в `World Outliner` выбираем **View Options** —  **Only in Current Level**:
    <br><br>![View Option — Only In Current Level](images/contentcreation_ue427/viewoption_onlyincurrentlevel.png)
2. Не снимая выделения, переходим во вкладку `Layers`
    > Если вкладки `Layers` нет, то включить её можно через **Window** — **Layers**
    <br><br>![View Option — Only In Current Level](images/contentcreation_ue427/enablelayerwindow.png)
3. ПКМ по пустой области вкладки `Layers` — **Add Selected Actors to New Layer**
    ![Layers add selection](images/contentcreation_ue427/layers_addselection.png)
4. Называем слой в соответствии с уровнем `01_SUGAR`

## 4. Создание и настройка управляющей логики под плейлист Carrot.

Для отладки работы логики в `Actor Blueprint`, мы эмулируем команду из Carrot при помощи обычной клавиши на клавиатуре.

Добавление клавиши происходит следующим образом:
    <br>![Add Key Event](images/contentcreation_ue427/blueprint_keyevent.png)

Для удобства сделаем так, чтобы при нажатии на одну кнопку события поочередно переключались. Для этого используем ноду `Flip Flop`, подробней про ноду [в документации к Unreal Engine](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/FlowControl/#flipflop):
    <br>![Flip Flop node](images/contentcreation_ue427/blueprint_node_flipflop.png)

Проверяем работу в режиме `Play`. Нажимаем клавишу `Y`, смотрим как отрабатывает логика:
    <br>![Open Level in Play Mode](images/contentcreation_ue427/playmode.png)

Удостоверившись в работоспособности создаём событие, которое в дальнейшем будет использоваться Carrot для воспроизведения из плейлиста.

Делаем это через ноду `Add Custom Event`, подробней [в документации к Unreal Engine](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/Custom/):
    <br>![Custom Event node](images/contentcreation_ue427/blueprint_node_addcustomevent.png)

Добавляем событие на показ и отдельное событие на скрытие. Для удобства дальнейшего поиска добавляем к названию события префикс `CRRT_`:
    <br>![Custom Event node](images/contentcreation_ue427/blueprint_customeventadded.png)

Помимо отображения самой геометрии, нам также нужно скрывать всё содержимое сцены. В данном случае вместе с геометрией скрываться нужно ещё источнику освещения.

Для этого создадим соответствующую логику:
<br>Тип переменной `Scene Lights` — `Light`:
    <br>![Show Hide Actor](images/contentcreation_ue427/blueprint_showhideactor.png)

Разбирать её не будем, приложу только документацию по отдельным элементам:
1. [Переменные в Blueprint](https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Variables/)
2. [Массивы переменных в Blueprint](https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Arrays/)

Мы создали логику для скрытия света, но ещё не указали источники освещения на уровне сцены. Для этого:
1. В `World Outliner` выбираем `BP_Harvester`.
2. В вкладке `Details` находим переменную **Scene Lights**.
    <br>![Blueprint Instance Details](images/contentcreation_ue427/blueprint_instance_variable.png)
3. Указываем нужные источники освещения.
> Указывать можно только те источники света, которые находятся на одном уровне с **Blueprint Actor**.

> Если переменной в вкладке `Details` нет, проверяем, стоит ли галка `Instance Editable` в свойствах переменной:
<br><br>![Variable Instance Editable](images/contentcreation_ue427/blueprint_variable_instanceeditable.png)

4. Проверяем работу логики.

Повторяем манипуляции с `BP_SugarPile`.

На выходе получаем блупринты с 2 событиями на показ/скрытие геометрии вместе с источниками освещения и 2 событиями на воспроизведение/сброс анимации (только для `BP_Harvester`).

В **Blueprint Actor** вызываем и подключаем к ноде `Event BeginPlay` наше событие `CRRT_Actor_Hide`, чтобы при старте проекта объект был скрыт по умолчанию. Написав в поиске `call`, получаем список всех событий внутри блупринта для быстрой навигации:
<br><br>![Hide on Event Begin Play](images/contentcreation_ue427/blueprint_hideoneventbeginplay.png)

## 5. Финальные действия перед отправкой ассета.

Все элементы готовы, теперь необходимо подготовить ассет к отправке сборщику UE проекта. Для этого потребуется написать логику внутри `Level Blueprint` уровня `level_SUGAR`, которая будет обращаться к созданному **Blueprint Actor** и запрашивать у него созданные нами события (показ/скрытие/воспроизведение/сброс).

Обратиться к блупринту на уровне можно через ноду `Get Actor of Class` (не путать с `Get All Actors of Class`, которая возвращает массив всех совпадающих блупринтов на уровне, нам нужен только один объект).<br>

![Get Actor of Class](images/contentcreation_ue427/blueprint_getactorofclass.png)

Из `Return Value` вытягиваем новую ноду и в поиске ищем события, созданные для Carrot (префикс `CRRT`).<br>

![Call Function](images/contentcreation_ue427/blueprint_getactorofclass_callfunction.png)

Добавляем все необходимые события:

![Add Events to Level Blueprint](images/contentcreation_ue427/blueprint_eventsadded.png)

Проверяем, что из **Level Blueprint** все события вызываются и работают. Подключаем тестовые кнопки, отличные от тех, что были в **Blueprint Actor**, если их не удаляли из логики. Не забываем включить `Input` - `Auto Receive Input` - `Player 0`, чтобы нажатия кнопок считывались.

![Test Events in Level Blueprint](images/contentcreation_ue427/blueprint_testevents.png)

Когда убедились, что всё работает, идём в `Content Browser`, ПКМ по папке с готовым контентом `Fix Up Redirectors in Folder` и после этого жмём `Migrate`. Проверяем, что все файлы лежат на своих местах и мы не тянем без лишней надобности из других папок текстуры и прочее.

Закидываем папку с контентом на хранилку, телеграфируем сборщику и радуемся жизни.

# TODO
- [] 1.2 — Работа с сторонним контентом
- [] Виды реализации контента для Carrot. Разница, преимущества и недостатки.
    - [] Проверяем Pivot в блупринте
    - [] создание null в блупринте
    - Tag Hide
    - Layer Hide
    - Actor Bluprint
    - Sequencer
- [] Alembic Geometry Cache
- [] C4D Datasmith Import
- [] Метрика производительности, способы оптимизации
- [] Carrot Modular Asset Creation System (CMCCS)
- [] Troubleshooting
    - [] Translucency Output Velocity
    - [] Sort Translucency
    - [] Epic Quality disables shadows with distance. Switch to Cinematic Quality
    - [] Actor dissapears on camera zoom/move -> Bounding Scale Fix
    - [] ??? Translucent Material PixelDepth optimization
    - [] Alembic reset in sequecner